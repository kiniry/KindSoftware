<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>

<title>KindSoftware</title>

<link rel="stylesheet" type="text/css" media="screen" href="/stylesheets/kind.css" />

<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1" />
<meta http-equiv="Content-Language" content="en-us" />
<meta name="ROBOTS" content="ALL" />
<meta name="Copyright" content="Copyright (c) 2004-2005 Joseph Kiniry, KindSoftware LLC" />
<meta http-equiv="imagetoolbar" content="no" />
<meta name="MSSmartTagsPreventParsing" content="true" />

<meta name="description" content="formal methods in software engineering" />
<meta name="keywords" content="formal methods, kindsoftware" />

<link rel="help" href="https://www.kindsoftware.com/about/" title="Site Information" />

<meta name="Rating" content="General" />
<meta name="doc-class" content="Living Document" />

</head>

<body onload="window.defaultStatus='KindSoftware'" id="sectionthree">

<script type="text/javascript">
// you can also factor this into a library
  function include(id, path) {
    fetch(path)
    .then(response => {
      return response.text()
    })
    .then(data => {
      document.getElementById(id).innerHTML = data;
    });
  }
</script>

<div id="theory">
<div id="wrapper">

<!-- Kindsoftware Logo in Header -->

<div id="logo_header"></div>
<script>
include("logo_header", "/xml/logo_header.xml")
</script>

<div id="wrapper2">

<!-- Top Level Menu -->

<div id="top_level_menu"></div>
<script>
include("top_level_menu", "/xml/top_level_menu.xml")
</script>

<!-- End Top Level Menu -->

<!-- Main page on left and sidebar on right -->
<div id="pagebody">

<!-- Sidebar -->
<div id="sidebar">

<!-- Nature Photo -->
<img src="/images/aster.jpg" border="0" width="180" height="100" alt="Documents" name="aster" />

<!-- Sub menu within sidebar -->
<!-- All secondary menus are hidden except the ones under "subnavon" -->
<div id="subnav">
<ul>
  <li>
<div id="overview"></div>
<script>
include("overview", "/documents/xml/overview.xml")
</script>
  </li>
  <li>
<div id="mech_theory"></div>
<script>
include("mech_theory", "/documents/xml/mech_theory.xml")
</script>
  </li>
  <li>
<div id="news"></div>
<script>
include("news", "/documents/xml/news.xml")
</script>
  </li>
  <li>
<div id="proposals"></div>
<script>
include("proposals", "/documents/xml/proposals.xml")
</script>
  </li>
  <li>
<div id="published"></div>
<script>
include("published", "/documents/xml/published.xml")
</script>
  </li>
  <li>
<div id="reports"></div>
<script>
include("reports", "/documents/xml/reports.xml")
</script>
  </li>
  <li>
<div id="talks"></div>
<script>
include("talks", "/documents/xml/talks.xml")
</script>
  </li>
  <li>
<div id="tutorials"></div>
<script>
include("tutorials", "/documents/xml/tutorials.xml")
</script>
  </li>
  <li id="subnavon">
<div id="whitepapers"></div>
<script>
include("whitepapers", "/documents/xml/whitepapers.xml")
</script>
  </li>
</ul>
</div>
<!-- End submenus -->

</div>
<!-- End Sidebar -->

<!-- Main content on left side -->
<div id="maincontent">
<h2>Whitepapers</h2>
<h3>The KindSoftware Coding Standards</h3>
            
<h4>Table of Contents:</h4>
<ol>
  <li> <a href="index.html">Introduction</a> </li>
  <li> <a href="documentation.html">Documentation</a> </li>
  <li> <a href="naming.html">Naming Conventions</a> </li>
  <li> <a href="properties.html">Semantic Properties</a> </li>
<!--   <li> <a href="recommendations.html">General Recommendations</a> </li> -->
  <li> <a href="tools.html">Tools</a> </li>
  <li> <a href="examples.html">Code Examples</a> </li>
  <li> <a href="references.html">References</a> </li>
  <li> Specific Recommendations for:
      <ol>
        <li> Java </li>
        <li> <a href="eiffel.html">Eiffel</a> </li>
      </ol>
  </li>
  <li> <a href="credits.html">Credits</a> </li>
</ol>

<h2>Java Recommendations</h2>

<p> The following are coding <em>recommendations.</em> It is not
necessary to follow them to the letter, but we have found it helpful
to always keep them in mind. </p>

<dl>
  <dt> Do not use the <code>*</code> form of <code>import</code>. Be
      precise about what you are importing. Check that all declared
      <code>imports</code> are actually used. </dt>  
  <dd>
      Rationale: Otherwise, readers of your code will have a hard time
      understanding its context and dependencies. Some people even prefer
      not using <code>import</code> at all (thus requiring that every
      class reference be fully dot-qualified), which avoids all
      possible ambiguity at the expense of requiring more source code
      changes if package names change.  (We, however, aren't that
      freaky.)
  </dd>
  <dt> When sensible, consider writing a <code>main()</code> method
      for the principal class in each program file. The
      <code>main()</code> method should provide a simple unit test or
      demo.  For many distributed classes there isn't a means by which
      you can build self-contained testing, so don't go crazy trying
      to make a <code>main()</code> method for everything. </dt>
  <dd>
      Rationale: Forms a basis for testing. Also provides usage
      examples.
  </dd>
  <dt> For stand-alone application programs, the class with the
      <code>main()</code> method should be separate from those containing
      normal classes. </dt>
  <dd>
      Rationale: Hard-wiring an application program in one of its
      component class files limits the potential for class reuse.
  </dd>
  <dt> Use our template files for the most common types of class
      files you create - applets, library classes, application classes,
      abstract classes, exceptions, etc. </dt>
  <dd>
      Rationale: Simplifies conformance to coding standards.  See the
      <a href="examples.html">Code Examples</a> section for links to our
      template classes.
  </dd>
  <dt> If you can conceive of someone else implementing a class's
      functionality differently, define an interface rather than an
      abstract class. Generally, use abstract classes only when they are
      "partially abstract"; i.e., they implement some functionality that
      must be shared across all subclasses. </dt>
  <dd>
      Rationale: Interfaces are more flexible than abstract classes.
      They support multiple inheritance and can be used as "mixins" in
      otherwise unrelated classes.
  </dd>
  <dt> Consider carefully whether any class should implement the
      <code>Cloneable</code> and/or <code>Serializable</code>
      interfaces. </dt>
  <dd>
      Rationale: These are "magic" interfaces in Java, that
      automatically add possibly-needed functionality only if so
      requested.
  </dd>
  <dt> Declare a class as <code>final</code> only if it is a subclass or
      implementation of a class or interface declaring all of its
      non-implementation-specific methods (a similar principle applies to
      the declaration of final methods). </dt>
  <dd>
      Rationale: Making a class final means that no one will ever get a
      chance to reimplement its functionality. Defining it instead to be a
      subclass of a base that is not final means that someone at least gets
      a chance to subclass the base with an alternate implementation, which
      will essentially always happen in the long run.
  </dd>
  <dt> <em>Never</em> declare instance fields as public. </dt>
  <dd>
      Rationale: The standard OO reasons. Making fields public gives up
      control over internal class structure. Also, if fields are public,
      methods cannot assume that they have valid values.
  </dd>
  <dt> <em>Never</em> rely on implicit initializers for instance
      fields (such as the fact that reference variables are initialized
      to <code>null</code>). </dt>
  <dd>
      Rationale: Minimizes initialization errors.
  </dd>
  <dt> Minimize statics (except for static final constants). </dt>
  <dd>
      Rationale: Static fields act like globals in non-OO languages.
      They make methods more context-dependent, hide possible side-effects,
      sometimes present synchronized access problems. and are the source of
      fragile, non-extensible constructions. Also, neither static fields
      nor static methods are overridable in any useful sense in
      subclasses.
  </dd>
  <dt> Generally prefer <code>long</code> to <code>int</code>, and
      <code>double</code> to <code>float</code>.  But use <code>int</code>
      for compatibility with standard Java constructs and classes (the
      primary example is array indexing and all of the things this implies
      about, for example, the maximum sizes of arrays). </dt>
  <dd>
      Rationale: Arithmetic overflow and underflow can be 4 billion
      times less likely with <code>longs</code> than with <code>ints</code>;
      similarly, fewer precision problems occur with <code>doubles</code>
      than with <code>floats</code>.  On the other hand, because of
      limitations in Java atomicity guarantees, use of longs and doubles
      must be synchronized in cases where use of ints and floats sometimes
      would not be.
  </dd>
  <dt> Use <code>final</code> and/or comment conventions (see the
      <code>modifies</code> and <code>values</code> properties) to indicate
      whether instance fields that never have their values changed after
      construction are intended to be constant (immutable) for the lifetime
      of the object (as opposed to those that just happen not to get
      assigned in a class, but could in a subclass). </dt>
  <dd>
      Rationale: Access to immutable instance fields generally does not
      require any synchronization control, but access to mutable fields
      generally does.
  </dd>
  <dt> Generally prefer <code>protected</code> to
      <code>private</code>. </dt>
  <dd>
      Rationale: Unless you have good reason for sealing-in a
      particular strategy for using a field or method, you might as well
      plan for change via subclassing. On the other hand, this almost
      always entails more work. Basing other code in a base class around
      <code>protected</code> fields and methods is harder, since you have
      to either loosen or check assumptions about their properties. (Note
      that in Java, <code>protected</code> methods are also accessible from
      unrelated classes in the same package. There is hardly ever any
      reason to exploit this, though.)
  </dd>
  <dt> Avoid unnecessary public instance field access and update
      methods.  Write public <code>get/set</code>-style methods only when
      they are intrinsic aspects of functionality. </dt>
  <dd>
      Rationale: Most instance fields in most classes must maintain
      values that are dependent on those of other instance
      fields. Allowing them to be read or written in isolation makes it
      harder to ensure that consistent sets of values are always used.
  </dd>
  <dt> Minimize direct internal access to instance fields inside
      methods.  Use <code>protected</code> access and update methods
      instead (or sometimes <code>public</code> ones if they exist
      anyway). </dt>
  <dd>
      Rationale: While inconvenient and sometimes overkill, this allows
      you to vary synchronization and notification policies associated with
      field access and change in the class and/or its subclasses, which
      is otherwise a serious impediment to extensiblity in concurrent OO
      programming.
  </dd>
  <dt> Avoid giving a field the same name as one in a superclass. </dt>
  <dd>
      Rationale: This is usually an error. If not, there must be a very
      good reason, which should always be explained with a
      <code>hides</code> property.
  </dd>
  <dt> Declare arrays as <code>Type[] arrayName</code> rather than
      <code>Type arrayName[]</code>. </dt>
  <dd>
      Rationale: The second form exists solely for incorrigible C
      programmers, and makes code less easily readable. The use of "[]"
      is part of the type, so it should be syntactically adjacent to the
      rest of the type name.
  </dd>
  <dt> Ensure that non-private <code>static</code> fields have
      sensible values, and that non-private <code>static</code> methods can
      be executed sensibly, even if no instances are ever created. Use
      static intitializers (<code>static { ... } </code>) if
      necessary. </dt>
  <dd>
      Rationale: You cannot assume that non-private statics will be
      accessed only after instances are constructed.
  </dd>
  <dt> Write methods that only do "one thing". In particular,
      separate out methods that change object state from those that just
      rely upon it. A classic example: in a <code>Stack</code> class, prefer
      having two methods <code>Object top()</code> and <code>void
      removeTop()</code> to having the single method <code>Object
      pop()</code> that does both. </dt>
  <dd>
      Rationale: This simplifies (sometimes, makes even possible)
      concurrency control and subclass-based extensions.
  </dd>
  <dt> Define return types as <code>void</code> unless they return
      results that are not (easily) accessible otherwise. (i.e., refrain
      from ever writing "<code>return this;</code>"). </dt>
  <dd>
      Rationale: While convenient, the resulting method cascades
      (<code>a.meth1().meth2().meth3()</code>) can be sources of
      synchronization problems and other failed expectations about the
      states of target objects.
  </dd>
  <dt> Avoid overloading methods on argument type (overriding on arity is
      OK, as in having a one-argument version versus a two-argument
      version). If you need to specialize behavior according to the class
      of an argument, consider instead choosing a general type for the
      nominal argument type (often <code>Object</code>,
      <code>Serializable</code> or <code>Cloneable</code>) and using
      conditionals which check <code>instanceof</code> (or, reflectively,
      <code>isAssignableFrom()</code>). Alternatives include techniques
      such as double-dispatching or, often best, reformulating methods
      (and/or their arguments) to remove dependence on exact argument
      type. </dt>
  <dd>
      Rationale: Java method resolution is static, based on the listed
      types rather than the actual argument types. This is compounded in
      the case of non-<code>Object</code> types with coercion charts. In
      both cases, most programmers have not committed the matching rules to
      memory. The results can be counterintuitive; thus the source of
      subtle errors.  For example, try to predict the output of this. Then
      compile and run. <br />
      <pre>     
      <code>
      class Classifier {
      String identify(Object x) {
      return "object";
      }
      String identify(Integer x) {
      return "integer";
      }
      }
      
      class Relay {
      String relay(Object obj) { 
      return (new Classifier()).identify(obj);
      }
      }
      
      public class App {
      public static void main(String [] args) {
      Relay relayer = new Relay();
      Integer i = new Integer(17);
      System.out.println(relayer.relay(i));
      }
      }
      </code>    
      </pre>
  </dd>
  <dt> Declare <code>concurrency</code> property values for at least all
      public methods.  Describe the assumed invocation context and/or
      rationale for existence or lack of synchronization.  If you don't
      know the concurrency semantics of your method, make it
      synchronized. </dt>
  <dd>
      Rationale: In the absence of planning out a set of concurrency
      control policies, declaring methods as synchronized at least
      guarantees safety (though not necessarily liveness) in concurrent
      contexts (<em>every</em> Java program is concurrent to at least some
      minimal extent). With full synchronization of all methods, the
      methods may lock up, but the object can never enter into randomly
      inconsistent states (and thus engage in stupidly or even dangerously
      wrong behavior) due to concurrency conflicts.  If you are worried
      about efficiency problems due to synchronization, learn enough about
      concurrent OO programming to plan out more efficient and/or less
      deadlock-prone policies (i.e., read "Concurrent Programming in
      Java" by Doug Lea).
  </dd>
  <dt> Prefer <code>synchronized</code> methods to
      <code>synchronized</code> blocks. </dt>
  <dd>
      Rationale: Better encsapsulation; less prone to subclassing
      snags; can be more efficient.
  </dd>
  <dt> If you override <code>Object.equals()</code>, also override
      <code>Object.hashCode()</code>, and vice-versa. </dt>
  <dd>
      Rationale: Essentially all containers and other utilities that
      group or compare objects in ways depending on equality rely on
      hashcodes to indicate possible equality. For further guidance see
      <a href = "https://www.ibm.com/java/education/portingc/index.html">
      Taligent's Java Cookbook</a>
  </dd>
  <dt> Override <code>readObject()</code> and
      <code>writeObject()</code> if a <code>Serializable</code> class
      relies on any state that could differ across processes, including, in
      particular, <code>hashCodes</code> and transient fields. </dt>     
  <dd> 
      Rationale: Otherwise, objects of the class will not transport
      properly.
  </dd>
  <dt> If you think that <code>clone()</code> may be called in a
      class you write, then explicitly define it (and declare the class to
      <code>implement Cloneable</code>). </dt>
  <dd>
      Rationale: The default shallow-copy version of
      <code>clone()</code> might not do what you want (and, in fact, does
      not in most cases).
  </dd>
  <dt> Always document the fact that a method invokes
      <code>wait()</code>. </dt>
  <dd>
      Rationale: Clients may need to take special actions to avoid
      nested monitor calls.
  </dd>
  <dt> Initialize all (reasonable) fields in all constructors,
      or do <em>not</em> initialize <em>any</em> fields in
      <em>any</em> constructors (rely on explicit or implicit
      initialization in field declarations) and always explicitly
      call the superclass constructor. </dt>
  <dd>
      If you don't initialize it, you don't know what value it
      really holds.  Consistency is the key in this rule so that a
      reviewer/user/tool doesn't have to search around for every
      initialization.
  </dd>
  <dt> Whenever reasonable, define a default (no-argument) constructor so
      objects can be created via <code>Class.newInstance()</code>. </dt>
  <dd>
      Rationale: This allows classes of types unknown at compile time
      to be dynamically loaded and instantiated (as is done for example when
      loading unknown Applets from html pages). In Java 1.1 and later,
      reflection alleviates the need for no-argument constructors somewhat,
      but many classes which dynamically instantiate other classes at
      runtime still depend on their presence.
  </dd>
  <dt> Prefer <code>abstract</code> methods in base classes to those
      with default no-op implementations. Also, if there is a common
      default implementation, consider instead writing it as a
      <code>protected</code> method so that subclass authors can just write
      a one-line implementation to call the default. </dt>
  <dd>
      Rationale: The Java compiler will force subclass authors to
      implement <code>abstract</code> methods, avoiding problems which
      occur when they forget to do so but should have.
  </dd>
  <dt> <em>Always</em> use method <code>equals</code> instead of
      operator <code>==</code> when comparing objects. In particular, do not
      use <code>==</code> to compare <code>Strings</code>. </dt>    
  <dd>
      Rationale: If someone defined an <code>equals</code> method to
      compare objects, then they want you to use it. Otherwise, the default
      implementation of <code>Object.equals()</code> is just to use
      <code>==</code>.
  </dd>
  <dt> Never use <code>suspend()/resume()</code> pairs to implement
      synchronization with threads. </dt>
  <dd>
      Rationale: The <code>suspend()</code> and <code>resume()</code>
      are inherently fragile, and have even been deprecated by JavaSoft as
      of JDK 1.2.
  </dd>
  <dt> Always embed <code>wait()</code> calls in <code>while</code> loops
      which re-wait if the condition being waited for does not hold. </dt>
  <dd>
      Rationale: When a <code>wait()</code> wakes up, there is no
      guarantee that the condition it is waiting for has become true.
  </dd>
  <dt> Use <code>notifyAll()</code> instead of <code>notify()</code>. </dt>    
  <dd>
      Rationale: Classes that use only <code>notify()</code> can
      normally only support at most one kind of wait condition across all
      methods in the class and all possible subclasses.
  </dd>
  <dt> Declare a local variable only at that point in the code where
      you know what its initial value should be. </dt>     
  <dd>
      Rationale: Minimizes bad assumptions about values of variables.
      Of course, you should know about the initial value of most local
      variables at the beginning of the method.  Only one-off (temporary,
      loop, etc.) variables should be declared within the body of a
      method.
  </dd>
  <dt> Name temporary and loop variables appropriately. </dt>
  <dd>
      Rationale: Lets the reader immediately know that the variable in
      question doesn't have a legitimate value unless it is within the code
      block of its declaration.
  </dd>
  <dt> Declare and initialize a new local variable rather than
      reusing (reassigning) an existing one whose value happens to no
      longer be used at that program point. </dt>
  <dd>
      Rationale: Minimizes bad assumptions about values of
      variables.
  </dd>
  <dt> Assign <code>null</code> to any reference variable which is no
      longer being used. This includes, especially, elements of
      arrays. </dt>
  <dd>
      Rationale: Enables the Java garbage collector to do its job.
  </dd>
  <dt> Avoid assignments ("<code>=</code>") inside <code>if</code>
      and <code>while</code> conditions. </dt>
  <dd>
      Rationale: These are almost always typos. The Java compiler
      catches cases where "<code>=</code>" should have been
      "<code>==</code>", <em>except</em> when the variable is a
      <code>boolean</code>.
  </dd>
  <dt> Document cases where the return value of a called method is
      ignored. </dt>
  <dd>
      Rationale: These are usually errors. If it is intentional,
      make the intent clear. A simple way to do this is: <br />
      <code>
      int unused = obj.methodReturningInt (args);
      </code>
  </dd>
  <dt> Ensure that there is ultimately a <code>catch</code> for all
      <em>unchecked</em> exceptions that can be dealt with. </dt>
  <dd>
      Rationale: Java allows you to not bother declaring or catching
      some common easily-handlable exceptions, for example
      <code>java.util.NoSuchElementException</code>. Declare and catch them
      anyway. It'll make your code more robust.
  </dd>
  <dt> Embed casts in conditionals. For example: </dt>
  <dd> 
      <code>
      C cx = null;
      if (x instanceof C)
      cx = (C) x;
      else evasiveAction();
      </code>
      Rationale: This forces you to consider what to do if the object
      is <em>not</em> an instance of the intended class, rather than just
      generating a <code>ClassCastException</code>.
  </dd>
  <dt> Document fragile constructions used solely for the sake of
      optimization. </dt>   
  <dd> 
      Rationale: See
      <a href = "https://www.cs.cmu.edu/~jch/java/optimization.html">Jonathan
      Hardwick's Java Optimization pages</a>.
  </dd>
  <dt> Do not require 100% conformance to rules of thumb such as the
      ones listed here! </dt>
  <dd>
      Rationale: Java allows you program in ways that do not conform to
      these rules for good reason. Sometimes they provide the only
      reasonable ways to implement things.  And some of these rules make
      programs less efficient than they might otherwise be, so they are
      meant to be conscientiously broken when performance is an issue.
  </dd>    
</dl>

</div>
</div>
<!-- End main content -->

<!-- Footer -->
<div id="footer"></div>
<script>
include("footer", "/xml/footer.xml")
</script>
</div>
<!-- End footer -->

</div>
</div>
</body>
</html>
